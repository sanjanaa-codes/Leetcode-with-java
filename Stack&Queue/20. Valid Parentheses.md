## Problem Statement
Given a string `s` containing only `'('`, `')'`, `'{'`, `'}'`, `'['`, and `']'`,  
determine whether the input string is <b>valid</b>.

A string is valid if:
1. Open brackets are closed by the same type of brackets.  
2. Open brackets are closed in the correct order.

```text
Example:
Input: s = "{[()]}"
Output: true
````

---

## Approach 1 ‚Äì Standard Stack Method

**Time Complexity:** O(N)
**Space Complexity:** O(N)

<details>
<summary>View Code</summary>

```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();

        for (char ch : s.toCharArray()) {
            if (ch == '(' || ch == '{' || ch == '[') {
                stack.push(ch);
            } else {
                if (stack.isEmpty()) return false;
                char top = stack.pop();
                if ((ch == ')' && top != '(') ||
                    (ch == '}' && top != '{') ||
                    (ch == ']' && top != '['))
                    return false;
            }
        }
        return stack.isEmpty();
    }
}
```

</details>

‚úîÔ∏è **Key Idea:** Push every opening bracket onto the stack.
When a closing bracket appears, pop and check for a matching pair.

---

## Approach 2 ‚Äì Using `peek()` for Readability

**Time Complexity:** O(N)
**Space Complexity:** O(N)

<details>
<summary>View Code</summary>

```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        if (s.length() < 2) return false;

        for (char ch : s.toCharArray()) {
            if (ch == '(' || ch == '{' || ch == '[') {
                stack.push(ch);
            } else {
                if (stack.isEmpty()) return false;
                char top = stack.peek();
                if ((ch == ')' && top != '(') ||
                    (ch == ']' && top != '[') ||
                    (ch == '}' && top != '{')) {
                    return false;
                }
                stack.pop();
            }
        }
        return stack.isEmpty();
    }
}
```

</details>

‚úîÔ∏è **Key Idea:** Use `peek()` before popping to improve clarity.
Readable, maintainable, and ideal for code reviews.

---

## Approach 3 ‚Äì Inline `pop()` Matching (Optimized)

**Time Complexity:** O(N)
**Space Complexity:** O(N)

<details>
<summary>View Code</summary>

```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        if (s.length() < 2) return false;

        for (char ch : s.toCharArray()) {
            if (ch == '(' || ch == '{' || ch == '[') {
                stack.push(ch);
            } else {
                if (stack.isEmpty()) return false;
                if ((ch == ')' && stack.pop() != '(') ||
                    (ch == ']' && stack.pop() != '[') ||
                    (ch == '}' && stack.pop() != '{')) {
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }
}
```

</details>

‚úîÔ∏è **Key Idea:** Inline popping reduces variable overhead and improves runtime slightly.
Compact and efficient.

---

## Comparison Summary

| Version  | Technique    | Runtime | Space | Key Point          |
| -------- | ------------ | ------- | ----- | ------------------ |
| üß© **1** | Stack + Pop  | O(N)    | O(N)  | Classic, reliable  |
| üîç **2** | Stack + Peek | O(N)    | O(N)  | Clearer logic      |
| ‚ö° **3**  | Inline Pop   | O(N)    | O(N)  | Cleanest & fastest |

---

## Edge Cases

| Input      | Output  | Explanation           |
| ---------- | ------- | --------------------- |
| `"()"`     | ‚úÖ true  | Simple balanced pair  |
| `"([]{})"` | ‚úÖ true  | Multiple nested pairs |
| `"(]"`     | ‚ùå false | Mismatched types      |
| `"((("`    | ‚ùå false | Unclosed brackets     |
| `"([)]"`   | ‚ùå false | Wrong order           |


### What happens if the stack.pop() and ch positions are flipped?

```java
import java.util.*;

public class Solution {
    public static boolean isValidParenthesis(String s) {
        Stack<Character> stack = new Stack<>();

        for (char ch : s.toCharArray()) {
            // Push opening brackets
            if (ch == '(' || ch == '[' || ch == '{') {
                stack.push(ch);
            } 
            // Handle closing brackets
            else {
                // Case 3: ")]}" ‚Üí closing before any opening
                if (stack.isEmpty()) return false;

                // Pop once for comparison (fixes earlier bug)
                char top = stack.pop();

                // Check mismatched pairs
                // Case 1: "([{" ‚Üí leftover open brackets (checked later)
                // Case 2: "()[}{}" ‚Üí mismatched mid pair
                // Case 4: "(]" ‚Üí incorrect pair
                // Case 6: "([)]" ‚Üí wrong nesting
                if ((top == '(' && ch != ')') ||
                    (top == '[' && ch != ']') ||
                    (top == '{' && ch != '}')) {
                    return false;
                }
            }
        }

        // Case 1: "([{" ‚Üí returns false (unclosed brackets)
        // Case 5: "(){}{}" ‚Üí valid, all closed properly
        return stack.isEmpty();
    }

    // --- Test Edge Cases ---
    public static void main(String[] args) {
        String[] tests = {
            "([{",     // 1. Unclosed brackets
            "()[}{}",  // 2. Mismatched mid pair
            ")]}",     // 3. Starts with closing
            "(]",      // 4. Incorrect matching type
            "(){}{}",  // 5. Valid multiple pairs
            "([)]"     // 6. Incorrect nesting
        };

        for (String test : tests) {
            System.out.println(test + " -> " + isValidParenthesis(test));
        }
    }
}
```

### ‚úÖ Reason

* One pop per closing bracket ensures correct stack handling.
* Mismatch checks handle wrong order or type.
* Final `stack.isEmpty()` ensures all openings are closed.

---

## Tools & Concepts

* **Language:** Java
* **Concepts:** Stack, String Traversal, Conditional Matching
* **Core Idea:** Last-In-First-Out (LIFO) structure perfectly handles nested validations.

---

## Interview Insight

This problem demonstrates:

* Stack data structure proficiency
* Understanding of string iteration and conditional logic
* Ability to balance readability and optimization in code

---

<p align="center">
  <b>‚≠ê Author:</b> R J Sanjanaa<br>
  <i>‚ÄúWrite clean code. Think in stacks.‚Äù</i>
</p>


<p align="center">
  <b>Tags:</b> #Java #Stack #String #LeetCode #DSA
</p>
```
