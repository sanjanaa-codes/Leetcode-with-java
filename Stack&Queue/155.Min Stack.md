# üßÆ Min Stack ‚Äî All Approaches in Java

---

## üìò Problem Statement

Design a stack that supports `push()`, `pop()`, `top()`, and retrieving the **minimum element** in constant time.

Implement the `MinStack` class:

* `MinStack()` initializes the stack object.
* `void push(int val)` pushes the element `val` onto the stack.
* `void pop()` removes the element on the top of the stack.
* `int top()` gets the top element.
* `int getMin()` retrieves the minimum element in the stack.

üîó **LeetCode:** [155. Min Stack](https://leetcode.com/problems/min-stack/)

---

## **1. Brute Force (Scan for Minimum)**

**Idea:**
Store all elements in a single stack (or ArrayList).
When `getMin()` is called, scan all elements to find the minimum.

**Edge Case:** Multiple equal minimums ‚Äî scanning ensures correctness.

```java
class MinStack {
    private Stack<Integer> stack;

    public MinStack() {
        stack = new Stack<>();
    }

    public void push(int val) {
        stack.push(val);
    }

    public void pop() {
        stack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        int min = Integer.MAX_VALUE;
        for (int v : stack) min = Math.min(min, v);
        return min;
    }
}
```

### **Dry Run**

*(push -2, push 0, push -3, getMin, pop, top, getMin)*

| Operation | Stack     | top() | getMin() |
| --------- | --------- | ----- | -------- |
| push(-2)  | [-2]      | -2    | -2       |
| push(0)   | [-2,0]    | 0     | -2       |
| push(-3)  | [-2,0,-3] | -3    | -3       |
| getMin()  | [-2,0,-3] | -3    | **-3**   |
| pop()     | [-2,0]    | 0     | -2       |
| top()     | [-2,0]    | **0** | -2       |
| getMin()  | [-2,0]    | 0     | **-2**   |

### **Complexity**

* **push:** O(1)
* **pop:** O(1)
* **top:** O(1)
* **getMin:** O(n) ‚Äî full scan
* **Space:** O(n)

**Notes:**
Simple to implement, but `getMin()` is slow ‚Äî not ideal for large inputs.

---

## **2. Better ‚Äî Two Stack Approach**

**Idea:**
Use one stack for values and another (`minStack`) to track current minimums.
Push to `minStack` only when a new minimum (or equal minimum) appears.

**Edge Case:** Handles duplicate minimums correctly with `<=`.

```java
class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minStack;

    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }

    public void push(int val) {
        stack.push(val);
        if (minStack.isEmpty() || val <= minStack.peek()) {
            minStack.push(val);
        }
    }

    public void pop() {
        int removed = stack.pop();
        if (removed == minStack.peek()) {
            minStack.pop();
        }
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

### **Dry Run**

| Operation | Main Stack   | Min Stack  | getMin() |
| --------: | ------------ | ---------- | -------: |
|  push(-2) | [-2]         | [-2]       |       -2 |
|   push(0) | [-2, 0]      | [-2]       |       -2 |
|  push(-3) | [-2, 0, -3]  | [-2, -3]   |       -3 |
|  getMin() | [-2,0,-3]    | [-2,-3]    |   **-3** |
|     pop() | [-2,0]       | [-2]       |       -2 |
|     top() | [-2,0]       | [-2]       |    **0** |
|  getMin() | [-2,0]       | [-2]       |   **-2** |
|  push(-2) | [-2,0,-2]    | [-2, -2]   |       -2 |
|  push(-2) | [-2,0,-2,-2] | [-2,-2,-2] |       -2 |
|  getMin() | ...          | ...        |   **-2** |
|     pop() | [-2,0,-2]    | [-2,-2]    |       -2 |
|  getMin() | [-2,0,-2]    | [-2,-2]    |   **-2** |

### **Complexity**

* **push:** O(1)
* **pop:** O(1)
* **top:** O(1)
* **getMin:** O(1)
* **Space:** O(n) (worst case: all values are minimums)

**Notes:**
Most common interview solution. Efficient and easy to reason about.

---

## **3. Optimal ‚Äî One Stack of Pairs (value, minSoFar)**

**Idea:**
Each push stores the element **and** the current minimum up to that point.
This avoids maintaining two separate stacks while ensuring O(1) access.

```java
class MinStack {
    private Stack<int[]> stack; // each int[] = {value, minSoFar}

    public MinStack() {
        stack = new Stack<>();
    }

    public void push(int val) {
        if (stack.isEmpty()) {
            stack.push(new int[]{val, val});
        } else {
            int currMin = Math.min(val, stack.peek()[1]);
            stack.push(new int[]{val, currMin});
        }
    }

    public void pop() {
        stack.pop();
    }

    public int top() {
        return stack.peek()[0];
    }

    public int getMin() {
        return stack.peek()[1];
    }
}
```

### **Dry Run**

| Operation | Stack (pairs: (val,minSoFar)) | top() | getMin() |
| --------: | ----------------------------- | ----: | -------: |
|  push(-2) | [(-2,-2)]                     |    -2 |       -2 |
|   push(0) | [(-2,-2),(0,-2)]              |     0 |       -2 |
|  push(-3) | [(-2,-2),(0,-2),(-3,-3)]      |    -3 |       -3 |
|  getMin() | ...                           |    -3 |   **-3** |
|     pop() | [(-2,-2),(0,-2)]              |     0 |       -2 |
|     top() | ...                           | **0** |       -2 |
|  getMin() | ...                           |     0 |   **-2** |
|  push(-2) | [(-2,-2),(0,-2),(-2,-2)]      |    -2 |       -2 |
|  push(-2) | [...,(-2,-2),(-2,-2)]         |    -2 |       -2 |
|  getMin() | ...                           |    -2 |   **-2** |
|     pop() | ...                           |    -2 |       -2 |
|  getMin() | ...                           |    -2 |   **-2** |

### **Complexity**

* **push:** O(1)
* **pop:** O(1)
* **top:** O(1)
* **getMin:** O(1)
* **Space:** O(n)

**Notes:**
Cleanest and most space-efficient design.
Single stack with constant-time all operations.

---

## ‚öñÔ∏è **Comparison Summary**

| Version | Technique             | getMin() | Space | Notes                     |
| :------ | :-------------------- | :------- | :---- | :------------------------ |
| ü™ú 1    | Single Stack (Brute)  | O(N)     | O(N)  | Simple but slow           |
| ‚öôÔ∏è 2    | Two Stacks (Better)   | O(1)     | O(N)  | Clean, easy to understand |
| üöÄ 3    | Stack of Pairs (Best) | O(1)     | O(N)  | Fastest, most elegant     |

---

## üí° **Interview Tip**

* Emphasize how *minimum tracking is independent of stack order*.
* Be ready to explain **why you don‚Äôt need to traverse the stack** for the minimum in the optimal approach.

---

<p align="center"> <b>‚≠ê Author:</b> R J Sanjanaa<br> <i>‚ÄúThink in pairs. Store the min.‚Äù</i> </p>  
<p align="center"> #Java #Stack #Design #LeetCode #DSA </p>

---
