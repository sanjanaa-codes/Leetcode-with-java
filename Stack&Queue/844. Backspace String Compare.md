```markdown
# Backspace String Compare

## Problem Statement
Given two strings `s` and `t`, return `true` if they are equal when both are typed into empty text editors.  
`'#'` means a backspace character.

Note that after processing the backspaces, both strings should match to be considered equal.

### Example 1
```

Input: s = "ab#c", t = "ad#c"
Output: true
Explanation: Both become "ac".

```

### Example 2
```

Input: s = "ab##", t = "c#d#"
Output: true
Explanation: Both become "".

```

### Example 3
```

Input: s = "a#c", t = "b"
Output: false
Explanation: s becomes "c" and t becomes "b".

````

---

## Approach 1 – Using Stack

### Idea
- Traverse both strings.
- Use two stacks (`st1`, `st2`) to simulate typing and backspace operations.
- When encountering `'#'`, pop the top character if the stack is not empty.
- Compare the final stacks for equality.

---

### Code

```java
import java.util.Stack;

class Solution {
    public boolean backspaceCompare(String s, String t) {
        Stack<Character> st1 = new Stack<>();
        Stack<Character> st2 = new Stack<>();

        for (char ch : s.toCharArray()) {
            if (ch != '#') st1.push(ch);
            else if (!st1.isEmpty()) st1.pop();
        }

        for (char ch : t.toCharArray()) {
            if (ch != '#') st2.push(ch);
            else if (!st2.isEmpty()) st2.pop();
        }

        return st1.equals(st2);
    }
}
````

---

### Complexity Analysis

* **Time Complexity:** O(n + m)
  Each character of both strings is processed once.
* **Space Complexity:** O(n + m)
  In the worst case, both stacks hold all characters.

---

## Approach 2 – Two Pointer (Optimized)

### Idea

Instead of using stacks, traverse both strings backward.
Skip characters using a counter when `'#'` appears.
Compare valid characters directly without extra space.

### Code

```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        int i = s.length() - 1;
        int j = t.length() - 1;
        int skipS = 0, skipT = 0;

        while (i >= 0 || j >= 0) {
            while (i >= 0) {
                if (s.charAt(i) == '#') { skipS++; i--; }
                else if (skipS > 0) { skipS--; i--; }
                else break;
            }

            while (j >= 0) {
                if (t.charAt(j) == '#') { skipT++; j--; }
                else if (skipT > 0) { skipT--; j--; }
                else break;
            }

            if (i >= 0 && j >= 0 && s.charAt(i) != t.charAt(j)) return false;
            if ((i >= 0) != (j >= 0)) return false;

            i--; j--;
        }

        return true;
    }
}
```

---

### Complexity Analysis

* **Time Complexity:** O(n + m)
  Each character is visited once.
* **Space Complexity:** O(1)
  No additional data structure used.

---

## Comparison

| Approach | Technique   | Time     | Space    | Description          |
| -------- | ----------- | -------- | -------- | -------------------- |
| 1        | Stack       | O(n + m) | O(n + m) | Simple and intuitive |
| 2        | Two Pointer | O(n + m) | O(1)     | Space-optimized      |

---

### Key Points

* The two-pointer approach is optimal and preferred in interviews.
* The stack-based solution is easier to understand for beginners.
* Both give the same correct result.

---

**Tag:** `#LeetCode844` `#Java` `#Stack` `#TwoPointer` `#String`

```
```
