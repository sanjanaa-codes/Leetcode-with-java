---

# 🎴 Maximize Card Points — Sliding Window in Java

---

## 📘 Problem Statement

You are given an integer array `cardPoints` and an integer `k`.

You can take cards from **either the beginning or the end** of the array, one at a time.
Your goal is to **maximize the total points** you can obtain after taking exactly `k` cards.

🔗 **LeetCode:** [1423. Maximum Points You Can Obtain from Cards](https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/)

---

## 🧩 **Intuition**

If you take cards only from the **start**, you miss possible large values at the **end**, and vice versa.
Instead of brute-forcing every combination, notice that:

> Picking `k` cards from the ends = leaving out a contiguous subarray of length `n - k`.

So, **maximize what you take ⇢ minimize what you skip** — this insight forms the basis of the sliding window technique.

---

## 🪜 **1. Brute Force Approach**

Try all possible combinations by choosing `i` cards from the start and `k-i` cards from the end.

```java
class Solution {
    public int maxScore(int[] cardPoints, int k) {
        int n = cardPoints.length;
        int maxSum = 0;
        
        for (int i = 0; i <= k; i++) {
            int leftSum = 0, rightSum = 0;
            
            // Take i cards from left
            for (int l = 0; l < i; l++)
                leftSum += cardPoints[l];
            
            // Take k-i cards from right
            for (int r = 0; r < k - i; r++)
                rightSum += cardPoints[n - 1 - r];
            
            maxSum = Math.max(maxSum, leftSum + rightSum);
        }
        return maxSum;
    }
}
```

### **Complexity**

* **Time:** O(k²)
* **Space:** O(1)

**Notes:** Works fine for small arrays, but inefficient for large inputs.

---

## ⚙️ **2. Optimized Sliding Window Approach**

We start with the **sum of first k cards**.
Then, we gradually move the window — removing one card from the left and adding one from the right — to find the maximum total.

```java
class Solution {
    public int maxScore(int[] cardPoints, int k) {
        int lsum = 0, rsum = 0;

        // 1️⃣ Take sum of first k cards
        for (int i = 0; i < k; i++) {
            lsum += cardPoints[i];
        }

        int maxsum = lsum;
        int rindex = cardPoints.length - 1;

        // 2️⃣ Move window from left to right
        for (int i = k - 1; i >= 0; i--) {
            lsum -= cardPoints[i];       // remove left card
            rsum += cardPoints[rindex--]; // add right card
            maxsum = Math.max(maxsum, lsum + rsum);
        }

        return maxsum;
    }
}
```

---

### 🧮 **Dry Run Example**

`cardPoints = [1, 2, 3, 4, 5, 6, 1], k = 3`

| Step | Left Pick | Right Pick | lsum | rsum | Total | maxsum |
| ---- | --------- | ---------- | ---- | ---- | ----- | ------ |
| Init | [1,2,3]   | []         | 6    | 0    | 6     | 6      |
| 1    | [1,2]     | [1]        | 3    | 1    | 4     | 6      |
| 2    | [1]       | [6,1]      | 1    | 7    | 8     | 8      |
| 3    | []        | [5,6,1]    | 0    | 12   | 12    | **12** |

✅ **Answer = 12**

---

## 💡 **Simplified Version**

```java
public class Solution {
    public static int maxPoints(int []arr , int K){
        int total = 0;
        int n = arr.length;
        int rindex = n - 1;

        // Initial sum of first K cards
        for(int i = 0; i < K; i++){
            total += arr[i];
        }

        int maxsum = total;

        // Shift the window
        for(int j = K - 1; j >= 0; j--){
            total -= arr[j];       // remove from left
            total += arr[rindex--]; // add from right
            maxsum = Math.max(maxsum, total);
        }

        return maxsum;
    }
}
```

---

### **Complexity**

| Operation | Complexity |
| --------- | ---------- |
| Time      | O(N)       |
| Space     | O(1)       |

**Notes:**
✅ Only one pass over the array (2N operations max).
✅ Constant extra space.
✅ Optimal for interview use.

---

## ⚖️ **Comparison Summary**

| Version | Technique      | Time  | Space | Notes                    |
| ------- | -------------- | ----- | ----- | ------------------------ |
| 🪜 1    | Brute Force    | O(k²) | O(1)  | Tests all combinations   |
| ⚙️ 2    | Sliding Window | O(N)  | O(1)  | Most efficient and clean |

---

## 💡 **Interview Tip**

* Explain **why minimizing the subarray you skip** is equivalent to maximizing your picked sum.
* Emphasize that **the window represents the subarray left behind**.
* Mention that **sliding window avoids recomputation** of overlapping sums — that’s where the optimization lies.

---

<p align="center">
  <b>⭐ Author:</b> R J Sanjanaa<br>
  <i>“Slide smart, not slow.”</i>
</p>

<p align="center">
  <b>Tags:</b> #Java #SlidingWindow #Arrays #LeetCode #DSA
</p>

---

