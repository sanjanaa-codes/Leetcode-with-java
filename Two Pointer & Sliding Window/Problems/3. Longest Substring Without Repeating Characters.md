# Length of Longest Substring Without Repeating Characters

**Problem Statement:**
Given a string `s`, find the length of the **longest substring** without repeating characters.

📘 **Reference:**
[Take U Forward — Length of Longest Substring Without Any Repeating Character](https://takeuforward.org/data-structure/length-of-longest-substring-without-any-repeating-character/)

---

## 1️⃣ Brute Force Approach

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int maxLength = 0;
        for (int i = 0; i < s.length(); i++) {
            HashSet<Character> set = new HashSet<>();
            for (int j = i; j < s.length(); j++) {
                if (set.contains(s.charAt(j))) {
                    break;
                }
                set.add(s.charAt(j));
                maxLength = Math.max(maxLength, j - i + 1);
            }
        }
        return maxLength;
    }
}
```

🕒 **Time Complexity:** O(n²)
📦 **Space Complexity:** O(n)

### 🔁 Example Dry Run (s = `"abcabcbb"`)

| i | j | s[j] | Set       | maxLength |
| - | - | ---- | --------- | --------- |
| 0 | 0 | 'a'  | {a}       | 1         |
| 0 | 1 | 'b'  | {a,b}     | 2         |
| 0 | 2 | 'c'  | {a,b,c}   | 3         |
| 0 | 3 | 'a'  | duplicate | break     |

---

## 2️⃣ Better Approach — Sliding Window with HashSet

```java
class Solution {
    public int lengthOfLongestSubstring(String str) {
        if (str.length() == 0)
            return 0;

        int maxLen = 0;
        Set<Character> set = new HashSet<>();
        int left = 0;

        for (int right = 0; right < str.length(); right++) {
            if (set.contains(str.charAt(right))) {
                while (left < right && set.contains(str.charAt(right))) {
                    set.remove(str.charAt(left));
                    left++;
                }
            }
            set.add(str.charAt(right));
            maxLen = Math.max(maxLen, right - left + 1);
        }

        return maxLen;
    }
}
```

🧠 **Concept Used:**
We use a **sliding window** from `left` to `right` ensuring all characters inside are unique.
Whenever a duplicate appears, shrink the window from the left until the duplicate is removed.

🔢 **Key Formula:**
`Length of current window = right - left + 1`

| Step | l | r | str[r] | Action                     | Set     | maxLen |
| ---- | - | - | ------ | -------------------------- | ------- | ------ |
| 1    | 0 | 0 | 'a'    | add                        | {a}     | 1      |
| 2    | 0 | 1 | 'b'    | add                        | {a,b}   | 2      |
| 3    | 0 | 2 | 'c'    | add                        | {a,b,c} | 3      |
| 4    | 0 | 3 | 'a'    | duplicate → remove a (l=1) | {b,c,a} | 3      |

⏱ **Time Complexity:** O(n)
📦 **Space Complexity:** O(n)

---

## 3️⃣ Optimal Approach — Sliding Window + HashMap (Jump the Left Pointer)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int left = 0, maxLen = 0;

        for (int right = 0; right < s.length(); right++) {
            char ch = s.charAt(right);

            if (map.containsKey(ch)) {
                left = Math.max(left, map.get(ch) + 1);
            }

            map.put(ch, right);
            maxLen = Math.max(maxLen, right - left + 1);
        }

        return maxLen;
    }
}
```

🧠 **Concept Used:**
Instead of removing elements one by one, store each character’s **last seen index** in a HashMap.
When a duplicate appears, **jump** the `left` pointer to `map.get(ch) + 1` to skip all invalid characters.

### 🧪 Example Dry Run (s = `"abcabcbb"`)

| Step | Left | Right | Char | Map           | maxLen |
| ---- | ---- | ----- | ---- | ------------- | ------ |
| 0    | 0    | 0     | a    | {a:0}         | 1      |
| 1    | 0    | 1     | b    | {a:0,b:1}     | 2      |
| 2    | 0    | 2     | c    | {a:0,b:1,c:2} | 3      |
| 3    | 1    | 3     | a    | {a:3,b:1,c:2} | 3      |
| 4    | 2    | 4     | b    | {a:3,b:4,c:2} | 3      |
| 5    | 3    | 5     | c    | {a:3,b:4,c:5} | 3      |
| 6    | 5    | 6     | b    | {a:3,b:6,c:5} | 3      |
| 7    | 6    | 7     | b    | {a:3,b:7,c:5} | 3      |

✅ **Final Answer:** 3
Possible Substrings → `"abc"`, `"bca"`, `"cab"`

---

## ⚡ Summary

| Approach    | Technique                | Time Complexity | Space Complexity | Notes                         |
| ----------- | ------------------------ | --------------- | ---------------- | ----------------------------- |
| Brute Force | Nested loops + HashSet   | O(n²)           | O(n)             | Try all substrings            |
| Better      | Sliding Window + HashSet | O(n)            | O(n)             | Maintain unique window        |
| ✅ Optimal   | Sliding Window + HashMap | O(n)            | O(n)             | Jump left pointer efficiently |

---

**💡 Key Insight:**
All solutions revolve around maintaining a **window of unique characters**, but using a **HashMap** lets us skip unnecessary checks — making it the most optimal approach.

---

### 🧮 **Complexity Analysis**

| Operation  | Time Complexity | Space Complexity |
| ---------- | --------------- | ---------------- |
| `push()`   | O(1)            | O(n)             |
| `pop()`    | O(1)            | O(n)             |
| `top()`    | O(1)            | O(n)             |
| `getMin()` | O(1)            | O(n)             |

**Notes:**
✅ Cleanest and most space-efficient design
✅ Achieves constant-time operations for all stack methods
✅ Uses a single stack (or stack of pairs) to track current minimum

---

### ⚖️ **Comparison Summary**

| Version                         | Technique                       | getMin() | Space | Notes                        |
| ------------------------------- | ------------------------------- | -------- | ----- | ---------------------------- |
| 🪜 **1. Single Stack (Brute)**  | Basic iteration                 | O(n)     | O(n)  | Simple but slow              |
| ⚙️ **2. Two Stacks (Better)**   | Maintain min stack              | O(1)     | O(n)  | Clean and easy to understand |
| 🚀 **3. Stack of Pairs (Best)** | Store (value, currentMin) pairs | O(1)     | O(n)  | Fastest and most elegant     |

---

### 💡 **Interview Tip**

* Emphasize how **minimum tracking is independent of stack order**.
* Be prepared to explain **why `getMin()` doesn’t require traversal** in the optimal approach.
* Mention how each stack entry “remembers” the minimum at the moment it was pushed.

---

<p align="center">
  <b>⭐ Author:</b> R J Sanjanaa<br>
  <i>“Think in pairs. Store the min.”</i>
</p>

<p align="center">
  <b>Tags:</b> #Java #Stack #Design #LeetCode #DSA
</p>

---
